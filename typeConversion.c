/*
しかし、逆に左辺の変数型が右辺の評価よりもサイズが小さい時は問題がありますね
この場合でもエラーは発生しません。値はデータを損失して代入されます
損失するという言葉を聞くと、心理的に良い印象は受けませんが実は意外とこれが大切であることもあります

intからcharなどに変換された場合は上位ビット切り捨てで代入されます
たとえば以下のプログラムを考えましょう
*/
#include <stdio.h>

int main()
{
        int var1 = 1279;
        unsigned char var2 = var1;

        printf("%d",var2);

        return 0;
}
/*
unsigned charが格納できるのは255までの整数です。つまり1279という数は表示できません
かなり数学的に勘のいい人は、このプログラムがなにを出力するかわかったでしょう
正解は 255 を出力します

なぜか、先ほども言いましたがunsigned char型にint型の変数var1が変換される時に上位ビットが切り捨てられています
結果として、下位8ビットが代入されているのです
32ビットの1279は2進数にすると 0000 0000 0000 0000 0000 0100 1111 1111 です
これを上位ビットを切り捨てて8ビットに直すと 1111 1111 つまり10進数で255になるのです

これは、理解した上で意図的に用いると便利です
あるデータの下位8ビットだけを抽出したい場合などはこの方法が用いられます

long doubleからdoubleなどの変換は、精度が落ちます
また、浮動小数点型から整数型への変換を行なうと小数点以下切り捨てになります
*/