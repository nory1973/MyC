/*
メモリアドレスの秘密
C言語によるプログラミング技術の中で、もっとも大切なものの一つがポインタです
一度でもC言語に触れたことがある方ならば、ポインタに対して「難しい」というイメージがあるかもしれません
実際、筆者も最初は抵抗がありました

しかし、ふたを開ければ大したことはありません
肝心なのはプログラム知識よりも、コンピュータアーキテクチャ（というほど大げさでもないが）の知識です
ポインタはメモリと深い関係があります

では、本題に入ります
ポインタとはそもそもなにか、簡単に言うと変数の一種です
これまで私たちは変数を扱ってきました。変数で文字列を扱うこともできるようになりました
ポインタも変数です。難しいことはありません

ポインタも変数なので、よくポインタ変数とも呼びます
問題は格納するものです。ポインタには変数のように定数を直接代入するわけではありません
ポインタにはメモリアドレスを代入するのです！！

変数は値をメモリのどこかに一時的に保存するものです
あらゆるデータには、それを管理するための「アドレス」が割り当てられます
郵便物を送るのに住所が必要なように、データにも住所があるのです

では、ポインタの前に変数がメモリのどこに保存されているかを実際に見てみましょう
変数のアドレスを表すには変数名の前にアンパサンド(&)をつけます
勘のいい人は思い出したかもしれませんが、scanf("%d",&var)というようにscanf()関数ですでにつかってます
このときの & 記号は変数のアドレスを関数に渡していたのです!
*/
#include <stdio.h>

int main()
{
        char str[3] = { 'A' , 'B' , 127};
        int count;

        for (count = 0 ; count <= 2 ; count++) {
                printf("str[%d]のメモリアドレス = %x\n" , count , &str[count] );
                printf("str[%d]のポインタに格納されている内容 = %x\n" , count , str[count] );
        }
        return 0;
}
/*
おそらく、値は違っても次ぎのような結果が得られたと思います

64fdf8
64fdf9
64fdfa

16進数で出力された結果が、配列変数str[]の各要素のメモリアドレスです
こうしてみると、配列の場合はメモリの領域の番号が順番に並んでいることがわかりますね
ただし、なぜ１ずつ増えているのかというとchar型が１バイトだからです
intだと4バイトなので4ずつ増えることになります（この辺は、後ほど詳しくやりましょう）
*/