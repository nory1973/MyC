#include <stdio.h>

int main()
{
        int bool1,bool2;

        printf("0か1を入力してください\n");
        scanf("%d",&bool1);
        printf("XORで否定します、0か1を入力してください\n");
        scanf("%d",&bool2);
        printf("答えは %d です",(bool1 || bool2) && !(bool1 && bool2));

        return 0;
}

/*
ではここで問題です
一方が真の場合のみ真を返すという論理演算はどのようにすればよいでしょう
|| 演算子 OR は、双方が真の場合でも真を返しました
そうではなく、一方が真の場合のみ真を返すのです。
この論理演算を排他的論理和 XORといいます

XOR はこれまでの3つの論理演算子を用いて代用することができます
二つのオペランドのうち一方が真であることを確認し
双方が真であれば否定して偽にすればよいのです
一方が真であれば真というのは論理和 bool1 || bool2
双方が真であればというのは論理積 bool1 && bool2 ですね
そして NOT で AND を否定した結果と最初の OR の結果を AND で評価します

(bool1 || bool2) && !(bool1 && bool2)

以下のプログラムはXORを作り、評価の結果を出力します
二つのオペランドを入力し、一方のオペランドが真の場合のみ真(1)を返します
*/
/*
論理式は必ず0か0以外かで評価されます
これを理解することで、より高度で完成度の高いフロー制御文を記述できます

ところで、論理積と論理和を用いるとショートカットという現象が発生します
ショートカットは、最低限必要な演算のみを行い、不必要な計算を省略する仕組みです
たとえば、 論理積では左辺のオペランドが偽の場合は右辺に関係なく偽になります
また、論理和では左辺のオペランドが真であれば右辺に関係なく結果は真です

この減少は、普段は意識する必要はありませんが
論理演算において、評価時に何らかの処理を発生させる場合は注意が必要です
例えば、右オペランドにインクリメントやデクリメント演算子をしていしている場合などです
*/