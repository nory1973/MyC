/*
ところで、ポインタ変数にもデータ型が存在します
char型の変数のアドレスはchar型のポインタに、int型の変数のアドレスはint型のポインタに代入していました
Cコンパイラはデータ型を使ってポインタの指す変数が何バイトであるかを調べます
これは間接参照による代入や比較をするときに、何バイトコピーしたり比較したりするかを知るためです
このため、特殊なケースを除いて型の異なるポインタ変数にアドレスを代入 したりすることはありません
*/
#include <stdio.h>

int main()
{
        char *po;
        int var1 , var2;

        var1 = 1028;
        po = &var1;     /*char型のポインタにint型の変数のアドレスを代入*/
        var2 = *po;     /*ここで間違った値がコピーされる*/

        printf("変数var1の値 = %d\n", var1);
        printf("変数var2の値 = %d\n", var2);
        printf("ポインタに格納されている内容 = %d\n" , *po);
        printf("ポインタに格納されているアドレス = %x\n" , po);
        return 0;
}
/*
またまたビットレベルのお話ですが
1028は2進数では 10 0000 0100 です
しかし、ポインタがchar型なので間接参照では8ビットまでしかコピーされません
ということは 0000 0100 すなわち10進数の4です
はい、予想どうり上のプログラムを実行すると4が出力されます
ポインタ変数が指すアドレスは確かにvar1ですが、
データ型が1バイトのために1バイトまでしかコピーされません
*/